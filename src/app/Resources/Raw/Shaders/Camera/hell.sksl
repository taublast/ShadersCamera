uniform float4 iMouse;           
uniform float  iTime;            
uniform float2 iResolution;      
uniform float2 iImageResolution; 
uniform shader iImage1;  
uniform float2 iOffset;  
uniform float2 iOrigin; 

const float COLOR_LEVELS = 16.0;
const float BASE_GLOW_RADIUS = 3.0;
const float BASELINE_SIZE = 1000.0;

/// Maps luminance to vibrant neon colors with smooth transitions
half3 neonColorMap(float luminance) {
    half3 color1 = half3(1.0, 0.2, 0.2);
    half3 color2 = half3(0.2, 0.2, 0.2);
    half3 color3 = half3(0.1, 0.1, 0.1);
    half3 color4 = half3(1.0, 0.0, 0.1);
    
    if (luminance <= 0.33) {
        float t = luminance / 0.33;
        return mix(color1, color2, smoothstep(0.0, 1.0, t));
    } else if (luminance <= 0.66) {
        float t = (luminance - 0.33) / 0.33;
        return mix(color2, color3, smoothstep(0.0, 1.0, t));
    } else {
        float t = (luminance - 0.66) / 0.34;
        return mix(color3, color4, smoothstep(0.0, 1.0, t));
    }
}

/// Creates smooth posterized color effect with anti-aliasing
half3 posterize(half3 color) {
    half3 quantized = floor(color * COLOR_LEVELS + 0.5) / COLOR_LEVELS;
    return mix(quantized, color, 0.1);
}

/// Optimized neon glow using cross-pattern sampling (5 samples instead of 81)
float neonGlowFast(float2 coord, float glowRadius) {
    float2 renderingScale = iImageResolution.xy / iResolution.xy;
    float2 inputCoord = (coord - iOffset) * renderingScale;
    float2 texelSize = 1.0 / iImageResolution.xy;
    
    float glow = 0.0;
    
    half4 center = iImage1.eval(inputCoord);
    float centerLum = dot(center.rgb, half3(0.299, 0.587, 0.114));
    glow += centerLum * 2.0;
    
    half4 sample1 = iImage1.eval(inputCoord + float2(glowRadius, 0.0) * texelSize);
    glow += dot(sample1.rgb, half3(0.299, 0.587, 0.114));
    
    half4 sample2 = iImage1.eval(inputCoord + float2(-glowRadius, 0.0) * texelSize);
    glow += dot(sample2.rgb, half3(0.299, 0.587, 0.114));
    
    half4 sample3 = iImage1.eval(inputCoord + float2(0.0, glowRadius) * texelSize);
    glow += dot(sample3.rgb, half3(0.299, 0.587, 0.114));
    
    half4 sample4 = iImage1.eval(inputCoord + float2(0.0, -glowRadius) * texelSize);
    glow += dot(sample4.rgb, half3(0.299, 0.587, 0.114));
    
    return glow * 0.05;
}

half4 main(float2 fragCoord) {
    float imageScale = max(iImageResolution.x, iImageResolution.y) / BASELINE_SIZE;
    float GLOW_RADIUS = BASE_GLOW_RADIUS * imageScale;
    
    float2 renderingScale = iImageResolution.xy / iResolution.xy;
    float2 inputCoord = (fragCoord - iOffset) * renderingScale;
    
    half4 originalColor = iImage1.eval(inputCoord);
    
    half3 posterizedColor = posterize(originalColor.rgb);
    float luminance = dot(posterizedColor, half3(0.299, 0.587, 0.114));
    
    half3 neonColor = neonColorMap(luminance);
    
    float glowEffect = neonGlowFast(fragCoord, GLOW_RADIUS);
    neonColor += glowEffect * half3(1.0, 0.5, 1.0);
    
    float contrast = 1.2;
    neonColor = (neonColor - 0.5) * contrast + 0.5;
    
    neonColor = clamp(neonColor, 0.0, 1.0);
    
    return half4(neonColor, originalColor.a);
}