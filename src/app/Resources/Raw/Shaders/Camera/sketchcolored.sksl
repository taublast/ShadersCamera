uniform float4 iMouse;           // Mouse drag pos=.xy Click pos=.zw (pixels)
uniform float  iTime;            // Shader playback time (s)
uniform float2 iResolution;      // Viewport resolution (pixels)
uniform float2 iImageResolution; // iImage1 resolution (pixels)
uniform shader iImage1;          // Texture
uniform float2 iOffset;          // Top-left corner of DrawingRect
uniform float2 iOrigin;          // Mouse drag started here

const float COLOR_LEVELS = 16.0;
const float iLineWidth = 3.0;
const float iColorAlpha = 0.2; // Blend between original (0.0) and cartoon colors (1.0)
const float iHueShift = 0.0; // Hue adjustment in normalized range (-1.0 to 1.0)
const float iSaturation = 1.33; // Saturation multiplier (1.0 = normal, 0.0 = grayscale, >1.0 = more saturated)
const float iLightness = 1.0; // Lightness multiplier (1.0 = normal, <1.0 = darker, >1.0 = brighter)
const float iShadows = -0.1; // Shadow adjustment (-1.0 = darker shadows, 1.0 = brighter shadows)
const float iHighlights = 0.4; // Highlight adjustment (-1.0 = darker highlights, 1.0 = brighter highlights)

/// Color dodge blend mode
half3 colorDodge(in half3 src, in half3 dst) {
    return step(0.0, dst) * mix(min(half3(1.0), dst / (1.0 - src)), half3(1.0), step(1.0, src)); 
}

/// Converts color to grayscale
float greyScale(in half3 col) {
    return dot(col, half3(0.3, 0.59, 0.11));
}

/// Posterizes colors to create flat cartoon areas
half3 posterizeColor(half3 color) {
    return floor(color * COLOR_LEVELS + 0.5) / COLOR_LEVELS;
}

/// Convert RGB to HSL
half3 rgbToHsl(half3 rgb) {
    float maxVal = max(max(rgb.r, rgb.g), rgb.b);
    float minVal = min(min(rgb.r, rgb.g), rgb.b);
    float delta = maxVal - minVal;
    
    // Lightness
    float l = (maxVal + minVal) * 0.5;
    
    if (delta == 0.0) {
        return half3(0.0, 0.0, l); // Achromatic
    }
    
    // Saturation
    float s = l > 0.5 ? delta / (2.0 - maxVal - minVal) : delta / (maxVal + minVal);
    
    // Hue
    float h;
    if (maxVal == rgb.r) {
        h = (rgb.g - rgb.b) / delta + (rgb.g < rgb.b ? 6.0 : 0.0);
    } else if (maxVal == rgb.g) {
        h = (rgb.b - rgb.r) / delta + 2.0;
    } else {
        h = (rgb.r - rgb.g) / delta + 4.0;
    }
    h /= 6.0;
    
    return half3(h, s, l);
}

/// Convert HSL to RGB
half3 hslToRgb(half3 hsl) {
    float h = hsl.x;
    float s = hsl.y;
    float l = hsl.z;
    
    if (s == 0.0) {
        return half3(l, l, l); // Achromatic
    }
    
    float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
    float p = 2.0 * l - q;
    
    // Calculate RGB components
    float tr = h + 1.0/3.0;
    float tg = h;
    float tb = h - 1.0/3.0;
    
    // Normalize to [0,1]
    if (tr < 0.0) tr += 1.0;
    if (tr > 1.0) tr -= 1.0;
    if (tb < 0.0) tb += 1.0;
    if (tb > 1.0) tb -= 1.0;
    
    float r, g, b;
    
    // Red component
    if (tr < 1.0/6.0) r = p + (q - p) * 6.0 * tr;
    else if (tr < 1.0/2.0) r = q;
    else if (tr < 2.0/3.0) r = p + (q - p) * (2.0/3.0 - tr) * 6.0;
    else r = p;
    
    // Green component
    if (tg < 1.0/6.0) g = p + (q - p) * 6.0 * tg;
    else if (tg < 1.0/2.0) g = q;
    else if (tg < 2.0/3.0) g = p + (q - p) * (2.0/3.0 - tg) * 6.0;
    else g = p;
    
    // Blue component
    if (tb < 1.0/6.0) b = p + (q - p) * 6.0 * tb;
    else if (tb < 1.0/2.0) b = q;
    else if (tb < 2.0/3.0) b = p + (q - p) * (2.0/3.0 - tb) * 6.0;
    else b = p;
    
    return half3(r, g, b);
}

/// Apply HSL adjustments to color
half3 adjustHSL(half3 rgb, float hueShift, float satMult, float lightMult) {
    half3 hsl = rgbToHsl(rgb);
    
    // Adjust hue (wrap around)
    hsl.x = fract(hsl.x + hueShift);
    
    // Adjust saturation
    hsl.y = clamp(hsl.y * satMult, 0.0, 1.0);
    
    // Adjust lightness
    hsl.z = clamp(hsl.z * lightMult, 0.0, 1.0);
    
    return hslToRgb(hsl);
}

/// Apply shadows and highlights adjustments
half3 adjustShadowsHighlights(half3 rgb, float shadowsAdj, float highlightsAdj) {
    // Calculate luminance for masking
    float luminance = dot(rgb, half3(0.299, 0.587, 0.114));
    
    // Create smooth masks for shadows and highlights
    float shadowMask = 1.0 - smoothstep(0.0, 0.5, luminance);    // Stronger in dark areas
    float highlightMask = smoothstep(0.5, 1.0, luminance);       // Stronger in bright areas
    
    // Calculate adjustments
    float shadowAdjustment = shadowsAdj * shadowMask;
    float highlightAdjustment = highlightsAdj * highlightMask;
    
    // Apply brightness adjustments
    half3 adjustedRgb = rgb + half3(shadowAdjustment + highlightAdjustment);
    
    return clamp(adjustedRgb, 0.0, 1.0);
}

/// Fast 3x3 cartoon color blur - only 9 samples instead of 625
half3 fastCartoonBlur(float2 inputCoord, float scaleFactor) {
    half3 result = half3(0.0);
    float totalWeight = 0.0;
    
    for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
            float weight = exp(-float(i*i + j*j) * 0.5);
            float2 sampleCoord = inputCoord + float2(float(i), float(j)) * scaleFactor * 2.0;
            
            half3 sampleCol = iImage1.eval(sampleCoord).rgb;
            half3 samplePosterized = posterizeColor(sampleCol);
            float sampleLuminance = dot(samplePosterized, half3(0.299, 0.587, 0.114));
            half3 sampleCartoonColor = mix(half3(sampleLuminance), samplePosterized, 1.3) * 1.1;
            
            result += sampleCartoonColor * weight;
            totalWeight += weight;
        }
    }
    
    return result / totalWeight;
}

/// Fast 3x3 edge blur - only 9 samples instead of 81
half3 fastEdgeBlur(float2 inputCoord, float scaleFactor) {
    half3 result = half3(0.0);
    float totalWeight = 0.0;
    float edgeBlurScale = max(1.0, scaleFactor * 1.5);
    
    for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
            float weight = exp(-float(i*i + j*j) * 0.5);
            float2 sampleCoord = inputCoord + float2(float(i), float(j)) * edgeBlurScale * iLineWidth;
            result += iImage1.eval(sampleCoord).rgb * weight;
            totalWeight += weight;
        }
    }
    
    return result / totalWeight;
}

half4 main(float2 fragCoord) 
{	
    // Reference resolution for consistent line width
    float REFERENCE_SIZE = 1000.0;
    
    float2 renderingScale = iImageResolution.xy / iResolution.xy;
    float2 inputCoord = (fragCoord - iOffset) * renderingScale;
    float2 q = inputCoord / iImageResolution.xy;
    
    // Calculate scale factor for size-independent line width
    float imageSize = min(iImageResolution.x, iImageResolution.y);
    float scaleFactor = imageSize / REFERENCE_SIZE;
    
    half4 originalColor = iImage1.eval(inputCoord);
    half3 col = originalColor.rgb;
    
    // Apply HSL adjustments to original color
    half3 adjustedOriginalColor = adjustHSL(col, iHueShift, iSaturation, iLightness);
    
    // Apply shadows/highlights adjustments to original color
    adjustedOriginalColor = adjustShadowsHighlights(adjustedOriginalColor, iShadows, iHighlights);

    // Fast cartoon color processing - only 9 samples instead of 625
    half3 blurredCartoonColor = fastCartoonBlur(inputCoord, scaleFactor);
    
    // Apply HSL adjustments to cartoon colors too
    half3 adjustedCartoonColor = adjustHSL(blurredCartoonColor, iHueShift, iSaturation, iLightness);
    
    // Apply shadows/highlights adjustments to cartoon colors too
    adjustedCartoonColor = adjustShadowsHighlights(adjustedCartoonColor, iShadows, iHighlights);
    
    // Fast edge detection blur - only 9 samples instead of 81
    half3 blurred = fastEdgeBlur(inputCoord, scaleFactor);
    
    // Line detection - same as original
    half3 inv = half3(1.0) - blurred; 
    half3 lighten = colorDodge(col, inv);
    half3 edgeResult = half3(greyScale(lighten));
    
    // Simplified contrast - removed adaptive scaling for performance
    edgeResult = half3(pow(edgeResult.x, 8.0));
    
    // Simplified thresholding - removed adaptive scaling
    float cleanEdge = smoothstep(0.4, 0.75, edgeResult.x);
    
    // Simplified vignette - same effect but faster calculation
    float vignette = 0.4 + 0.6 * (1.0 - length(q - 0.5) * 1.4);
    cleanEdge *= clamp(vignette, 0.0, 1.0);
    
    // Blend between adjusted original and adjusted cartoon colors
    half3 blendedColors = mix(adjustedOriginalColor, adjustedCartoonColor, iColorAlpha);
    
    // Use blended colors for color areas, black for lines
    half3 finalColor = mix(half3(0.0, 0.0, 0.0), blendedColors, cleanEdge);
    
    return half4(clamp(finalColor, 0.0, 1.0), 1.0);
}