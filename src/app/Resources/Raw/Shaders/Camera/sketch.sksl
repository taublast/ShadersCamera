uniform float4 iMouse;            
uniform float  iTime;             
uniform float2 iResolution;      
uniform float2 iImageResolution;  
uniform shader iImage1;  
uniform shader iImage2;   
uniform float2 iOffset;  
uniform float2 iOrigin;  
uniform float4 iMargins;

// pixel independent, width is in points!

const float iLineWidth = 4.5;
const float eraseNoise = 1.045;
const float contrast = 9.0;

// Color dodge blend mode
half3 colorDodge(in half3 src, in half3 dst) {
    return step(0.0, dst) * mix(min(half3(1.0), dst / (1.0 - src)), half3(1.0), step(1.0, src)); 
}

// Converts color to grayscale
float greyScale(in half3 col) {
    return dot(col, half3(0.3, 0.59, 0.11));
}

// Detects edges for continuous line drawing with size-independent sampling
float detectEdges(float2 coord, float scaleFactor, float lineWidth) {
    float2 texelSize = (1.0 / iImageResolution.xy) * scaleFactor * lineWidth;
    
    half4 center = iImage1.eval(coord);
    half4 left = iImage1.eval(coord - float2(texelSize.x, 0.0));
    half4 right = iImage1.eval(coord + float2(texelSize.x, 0.0));
    half4 up = iImage1.eval(coord - float2(0.0, texelSize.y));
    half4 down = iImage1.eval(coord + float2(0.0, texelSize.y));
    
    float centerLum = greyScale(center.rgb);
    float leftLum = greyScale(left.rgb);
    float rightLum = greyScale(right.rgb);
    float upLum = greyScale(up.rgb);
    float downLum = greyScale(down.rgb);
    
    float sobelX = -leftLum + rightLum;
    float sobelY = -upLum + downLum;
    
    return sqrt(sobelX * sobelX + sobelY * sobelY);
}

// Creates directional blur for line continuity with size-independent width
half3 directionalBlur(float2 coord, float2 direction, float scaleFactor, float lineWidth) {
    half3 result = half3(0.0);
    float totalWeight = 0.0;
    
    for (int i = -3; i <= 3; i++) {
        float weight = exp(-float(i * i) * 0.2);
        float2 sampleCoord = coord + direction * float(i) * 2.0 * scaleFactor * lineWidth;
        result += iImage1.eval(sampleCoord).rgb * weight;
        totalWeight += weight;
    }
    
    return result / totalWeight;
}

// Main fragment shader for continuous sketch lines effect with size-independent line width
half4 main(float2 fragCoord) {
    // Reference resolution for consistent line width (adjust as needed)
    float REFERENCE_SIZE = 1000.0;
    
    float2 renderingScale = iImageResolution.xy / iResolution.xy;
    float2 inputCoord = (fragCoord - iOffset) * renderingScale;
    float2 q = inputCoord / iImageResolution.xy;
    
    // Calculate scale factor for size-independent line width
    float imageSize = min(iImageResolution.x, iImageResolution.y);
    float scaleFactor = imageSize / REFERENCE_SIZE;
    
    half3 col = iImage1.eval(inputCoord).rgb;
    
    half3 blurred = half3(0.0);
    float totalWeight = 0.0;
    
    for (int i = -2; i <= 2; i++) {
        for (int j = -2; j <= 2; j++) {
            float weight = exp(-float(i*i + j*j) * 0.2);
            float2 sampleCoord = inputCoord + float2(float(i), float(j)) * 1.5 * scaleFactor * iLineWidth;
            blurred += iImage1.eval(sampleCoord).rgb * weight;
            totalWeight += weight;
        }
    }
    blurred = blurred / totalWeight;
    
   
    float2 texelSize = (1.0 / iImageResolution.xy) * scaleFactor * iLineWidth;

    float gradX = greyScale(iImage1.eval(inputCoord + float2(texelSize.x, 0.0)).rgb) - 
                  greyScale(iImage1.eval(inputCoord - float2(texelSize.x, 0.0)).rgb);
    float gradY = greyScale(iImage1.eval(inputCoord + float2(0.0, texelSize.y)).rgb) - 
                  greyScale(iImage1.eval(inputCoord - float2(0.0, texelSize.y)).rgb);
 
      
    half3 inv = half3(1.0) - blurred; 
    half3 lighten = colorDodge(col, inv) * eraseNoise;
    half3 res = half3(greyScale(lighten));
    
    res = half3(pow(res.x, contrast)); 
    
    return half4(res, 1.0); 
}