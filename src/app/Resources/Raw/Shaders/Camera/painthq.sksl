uniform float4 iMouse;            
uniform float  iTime;             
uniform float2 iResolution;      
uniform float2 iImageResolution;  
uniform shader iImage1;  
uniform shader iImage2;   
uniform float2 iOffset;  
uniform float2 iOrigin;  
uniform float4 iMargins;

// Sketch parameters
const float iLineWidth = 3.0;

// Color enhancement parameters (adjustable)
const float COLOR_LEVELS = 32.0;        // Color quantization levels
const float WARMTH_BOOST = 1.08;        // Warm tint boost (makes skin look better)
const float RETRO_SATURATION = 1.25;    // Saturation boost (keep it natural)
const float CONTRAST_ENHANCE = 1.5;     // Contrast enhancement
const float LINE_OPACITY = 0.8;         // Opacity of sketch lines (0.0 = no lines, 1.0 = full lines)

// Color dodge blend mode
half3 colorDodge(in half3 src, in half3 dst) {
    return step(0.0, dst) * mix(min(half3(1.0), dst / (1.0 - src)), half3(1.0), step(1.0, src)); 
}

// Converts color to grayscale
float greyScale(in half3 col) {
    return dot(col, half3(0.3, 0.59, 0.11));
}

/// Apply retro color enhancements from pixel shader
half3 enhanceColors(half3 color) {
    // Enhance contrast gently
    half3 contrastedColor = mix(color, (color - 0.5) * CONTRAST_ENHANCE + 0.5, 0.7);
    
    // Add warm, appealing tint
    contrastedColor.r *= WARMTH_BOOST;
    contrastedColor.g *= (WARMTH_BOOST * 0.98);
    
    // Smart color quantization
    half3 quantized = floor(contrastedColor * COLOR_LEVELS + 0.5) / COLOR_LEVELS;
    
    // Boost saturation but keep it natural
    half luminance = dot(quantized, half3(0.299, 0.587, 0.114));
    quantized = mix(half3(luminance), quantized, RETRO_SATURATION);
    
    return clamp(quantized, 0.0, 1.0);
}

// Detects edges for continuous line drawing with size-independent sampling
float detectEdges(float2 coord, float scaleFactor, float lineWidth) {
    float2 texelSize = (1.0 / iImageResolution.xy) * scaleFactor * lineWidth;
    
    half4 center = iImage1.eval(coord);
    half4 left = iImage1.eval(coord - float2(texelSize.x, 0.0));
    half4 right = iImage1.eval(coord + float2(texelSize.x, 0.0));
    half4 up = iImage1.eval(coord - float2(0.0, texelSize.y));
    half4 down = iImage1.eval(coord + float2(0.0, texelSize.y));
    
    float centerLum = greyScale(center.rgb);
    float leftLum = greyScale(left.rgb);
    float rightLum = greyScale(right.rgb);
    float upLum = greyScale(up.rgb);
    float downLum = greyScale(down.rgb);
    
    float sobelX = -leftLum + rightLum;
    float sobelY = -upLum + downLum;
    
    return sqrt(sobelX * sobelX + sobelY * sobelY);
}

// Creates directional blur for line continuity with size-independent width
half3 directionalBlur(float2 coord, float2 direction, float scaleFactor, float lineWidth) {
    half3 result = half3(0.0);
    float totalWeight = 0.0;
    
    for (int i = -3; i <= 3; i++) {
        float weight = exp(-float(i * i) * 0.2);
        float2 sampleCoord = coord + direction * float(i) * 2.0 * scaleFactor * lineWidth;
        result += iImage1.eval(sampleCoord).rgb * weight;
        totalWeight += weight;
    }
    
    return result / totalWeight;
}

// Main fragment shader - enhanced colors with sketch lines on top
half4 main(float2 fragCoord) {
    // Reference resolution for consistent line width
    float REFERENCE_SIZE = 1000.0;
    
    float2 renderingScale = iImageResolution.xy / iResolution.xy;
    float2 inputCoord = (fragCoord - iOffset) * renderingScale;
    float2 q = inputCoord / iImageResolution.xy;
    
    // Calculate scale factor for size-independent line width
    float imageSize = min(iImageResolution.x, iImageResolution.y);
    float scaleFactor = imageSize / REFERENCE_SIZE;
    
    half3 col = iImage1.eval(inputCoord).rgb;
    
    // Apply retro color enhancements to create beautiful base image
    half3 enhancedCol = enhanceColors(col);
    
    // Sketch effect processing for line detection
    half3 blurred = half3(0.0);
    float totalWeight = 0.0;
    
    for (int i = -2; i <= 2; i++) {
        for (int j = -2; j <= 2; j++) {
            float weight = exp(-float(i*i + j*j) * 0.2);
            float2 sampleCoord = inputCoord + float2(float(i), float(j)) * 1.5 * scaleFactor * iLineWidth;
            blurred += iImage1.eval(sampleCoord).rgb * weight;
            totalWeight += weight;
        }
    }
    blurred = blurred / totalWeight;
    
    float edgeStrength = detectEdges(inputCoord, scaleFactor, iLineWidth);
    
    float2 texelSize = (1.0 / iImageResolution.xy) * scaleFactor * iLineWidth;
    float gradX = greyScale(iImage1.eval(inputCoord + float2(texelSize.x, 0.0)).rgb) - 
                  greyScale(iImage1.eval(inputCoord - float2(texelSize.x, 0.0)).rgb);
    float gradY = greyScale(iImage1.eval(inputCoord + float2(0.0, texelSize.y)).rgb) - 
                  greyScale(iImage1.eval(inputCoord - float2(0.0, texelSize.y)).rgb);
    
    float2 edgeDirection = normalize(float2(-gradY, gradX));
    half3 directionalBlurred = directionalBlur(inputCoord, edgeDirection, scaleFactor, iLineWidth);
    
    blurred = mix(blurred, directionalBlurred, edgeStrength * 0.7);
    
    half3 inv = half3(1.0) - blurred; 
    half3 lighten = colorDodge(col, inv);
    half3 res = half3(greyScale(lighten));
    
    res = half3(pow(res.x, 6.0)); 
    
    res *= 0.3 + 0.7 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.2);
    
    // Calculate line strength (inverted - low res.x = strong lines)
    float lineStrength = (1.0 - res.x) * LINE_OPACITY;
    
    // Draw black lines ON TOP of the enhanced colored image
    half3 finalColor = mix(enhancedCol, half3(0.0, 0.0, 0.0), lineStrength);
    
    // Add subtle animated "digital" sparkle effect for fun
    float2 sparkleCoord = floor(fragCoord / 8.0);
    float sparkleNoise = fract(sin(dot(sparkleCoord, float2(12.9898, 78.233)) + iTime * 0.5) * 43758.5453);
    half luminance = dot(finalColor, half3(0.299, 0.587, 0.114));
    if (sparkleNoise > 0.98 && luminance > 0.7) {
        finalColor += 0.05; // Subtle highlight sparkle on bright areas
    }
    
    return half4(clamp(finalColor, 0.0, 1.0), 1.0);
}